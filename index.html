<!DOCTYPE html>
<!-- Website template by freewebsitetemplates.com -->
<html>
<head>
	<meta charset="UTF-8">
	<title>Projects I am working on and summary of some programming hacks</title>
	<link rel="stylesheet" href="css/style.css" type="text/css">
</head>
<body>
	<div class="background">
		<div class="page">
			<div class="logo">
				<span> <a href="index.html"><img src="images/logo.png" alt=""></a> </span>
			</div>
			<div class="sidebar">
				<ul>
					<li class="selected">
						<a href="index.html">Projects</a>
					</li>
					<li>
						<a href="blog_entries/overview.html">Tips &amp; Tricks</a>
					</li>
					<li>
						<a href="about.html">About</a>
					</li>
				</ul>
			</div>
			<div class="body">
				<ul>
					<li class="projects">
						<h3><a href="http://github.com/tobiashoppe/promnicat">Promnicat</a></h3>
						<br>
						<a href="http://github.com/tobiashoppe/promnicat"><img src="images/promnicat_logo.png" width="300" alt=""></a>						
						<p>
							PromniCAT is a framework to import various business process models of many business process model repositories into one generic database (therefore the "Pro" for process and "omni" in the name). This enables research on the entire collection across the boundaries of business process modeling notations.

							PromniCAT is completely written in JAVA. The database used for business process model persisting is <a href="http://www.orientechnologies.com/orient-db.htm">Orient DB</a>. For business process model analysis we use <a href="http://code.google.com/p/jbpt/">jBPT</a>, a graph analysis framework.

							You can get a large set of process models for evaluating your algorithms from the BPM Academic Initiative (<a href="http://bpmai.org/download/index.html">BPMAI</a>) homepage. The <a href="http://bpmai.org/download/index.html">BPMAI</a> homepage provides filters for choosing process models with desired process characteristics for your evaluation. PromniCAT offers a direct importer for the BPMAI process models to jump start your research.

						</p>
					</li>
					<li class="projects">
						<h3><a href="http://github.com/tobiashoppe/stammbaum">FamilyTree</a></h3>
						<p>
							<b>Project under development.</b>
						</p>
					</li>
					<li class="projects">
						<h3><a href="http://help.eclipse.org/mars/index.jsp?topic=%2Forg.eclipse.ocl.doc%2Fhelp%2FImpactAnalyzer.html">OCL Impact Analyzer</a></h3>
						<p>
							When Ecore metamodels use many OCL invariants and the models constrained by these invariants grow large, re-evaluating the invariants becomes a performance challenge. As OCL expressions can navigate freely across resource boundaries, changes to a model element in one resource can easily affect invariants for model elements in other resources. To reliably catch all invalidated constraints after a change it would be necessary to re-evaluate all invariants on all their context objects regardless their resource. This does not scale sufficiently well.
							<br>
							The ImpactAnalyzerFactory  interface allows tool builders to efficiently determine a much smaller set of model elements on which re-evaluation of expressions is necessary after a change.
						</p>
					</li>
					<li class="projects">
						<h3><a href="http://download.eclipse.org/ocl/javadoc/6.0.0/org/eclipse/ocl/ecore/opposites/OppositeEndFinder.html">OCL Opposite End Finder for EReferences</a></h3>
						<p>
							The Eclipse Modeling Framework (EMF) and its meta-meta model Ecore support uni-directional and bi-directional references. It is quite common that references are defined uni-directionally only because of saving storage space or separating meta models, which is problematic when implementing Object Constraint Language (OCL) constraints that require navigation against the direction of unidirectional references.
							<br>
							Opposite references declared by the annotation detail <i>OppositeEndFinder.PROPERTY_OPPOSITE_ROLE_NAME_KEY</i> on an EAnnotation with source <i>EMOFExtendedMetaData.EMOF_PACKAGE_NS_URI_2_0</i> are retrieved by scanning and caching the Ecore packages that this opposite end finder is aware of at the time of the request. The set of those packages is taken to be the set of EPackages resolved by an EPackage.Registry provided to getInstance(EPackage.Registry), or the default EPackage.Registry otherwise. In particular, this won't load any Ecore bundles not yet loaded. 
							<br>
							Further theoretical background is provided in the paper <a href="http://journal.ub.tu-berlin.de/eceasst/article/viewFile/440/428">&quot;Navigating Across Non-Navigable Ecore References via OCL&quot;</a>.
						</p>
					</li>
					<li class="projects">
						<h3><a href="http://github.com/tobiashoppe/iban-generator/">IBAN Generator</a></h3>
						<br>
						<a href="http://github.com/tobiashoppe/iban-generator/"><img src="images/ibangenerator.png" alt=""></a>
						<p>
							Generates an IBAN from given data.
						</p>
					</li>
				</ul>
			</div>
		</div>
	</div>
</body>
</html>
